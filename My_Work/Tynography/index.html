<html>
  <head>
    <title>
      CPC Challenge
    </title>

    <style>
      :root {
	--neon-blue: #00f3ff;
	--neon-pink: #ff00ff;
	--neon-purple: #bc13fe;
	--cyber-yellow: #f0db4f;
	--bg-dark: #0a0a0a;
}

body {
	margin: 0;
	background: var(--bg-dark);
	color: #fff;
	font-family: "Rajdhani", sans-serif;
	overflow-x: hidden;
	perspective: 1000px;
}

/* Canvas Containers */
#canvas-container,
#particle-system {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	z-index: 1;
}

.content-wrapper {
	position: relative;
	z-index: 2;
}

/* Cyberpunk Header */
.cyber-header {
	height: 100vh;
	display: flex;
	flex-direction: column;
	justify-content: center;
	align-items: center;
	position: relative;
}

.glitch-container {
	position: relative;
	overflow: hidden;
}

.cyber-glitch {
	font-family: "Syncopate", sans-serif;
	font-size: 8vw;
	color: var(--neon-blue);
	text-shadow: 0 0 10px var(--neon-blue);
	position: relative;
	animation: glitch-skew 1s infinite linear alternate-reverse;
}

.cyber-glitch::before,
.cyber-glitch::after {
	content: attr(data-text);
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
}

.cyber-glitch::before {
	color: var(--neon-pink);
	animation: glitch-effect 2s infinite;
	clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
	transform: translate(-2px, -2px);
}

.cyber-glitch::after {
	color: var(--neon-purple);
	animation: glitch-effect 2s infinite reverse;
	clip-path: polygon(0 60%, 100% 60%, 100% 100%, 0 100%);
	transform: translate(2px, 2px);
}

/* Floating Panels */
.floating-panel {
	position: absolute;
	width: 300px;
	background: rgba(0, 243, 255, 0.1);
	backdrop-filter: blur(10px);
	border: 1px solid var(--neon-blue);
	padding: 20px;
	border-radius: 5px;
	transform-style: preserve-3d;
}

.floating-panel.left {
	left: 50px;
	animation: float-left 4s ease-in-out infinite;
}

.floating-panel.right {
	right: 50px;
	animation: float-right 4s ease-in-out infinite;
}

/* Neon Text */
.neon-text {
	color: var(--neon-blue);
	text-shadow: 0 0 10px var(--neon-blue), 0 0 20px var(--neon-blue),
		0 0 30px var(--neon-blue);
	animation: neon-pulse 1.5s ease-in-out infinite alternate;
}

/* Cyber Quote */
.cyber-quote {
	position: relative;
	margin: 100px auto;
	max-width: 800px;
	padding: 40px;
	background: linear-gradient(
		45deg,
		rgba(0, 243, 255, 0.1),
		rgba(188, 19, 254, 0.1)
	);
	border: 2px solid var(--neon-blue);
	transform-style: preserve-3d;
	animation: quote-hover 5s ease-in-out infinite;
}

/* Animations */
@keyframes glitch-effect {
	0% {
		transform: translate(0);
	}
	20% {
		transform: translate(-5px, 5px);
	}
	40% {
		transform: translate(-5px, -5px);
	}
	60% {
		transform: translate(5px, 5px);
	}
	80% {
		transform: translate(5px, -5px);
	}
	100% {
		transform: translate(0);
	}
}

@keyframes glitch-skew {
	0% {
		transform: skew(0deg);
	}
	20% {
		transform: skew(2deg);
	}
	40% {
		transform: skew(-2deg);
	}
	60% {
		transform: skew(1deg);
	}
	80% {
		transform: skew(-1deg);
	}
	100% {
		transform: skew(0deg);
	}
}

@keyframes float-left {
	0%,
	100% {
		transform: translateZ(20px) translateY(0px) rotateY(5deg);
	}
	50% {
		transform: translateZ(40px) translateY(-20px) rotateY(-5deg);
	}
}

@keyframes float-right {
	0%,
	100% {
		transform: translateZ(20px) translateY(0px) rotateY(-5deg);
	}
	50% {
		transform: translateZ(40px) translateY(-20px) rotateY(5deg);
	}
}

@keyframes neon-pulse {
	from {
		text-shadow: 0 0 10px var(--neon-blue), 0 0 20px var(--neon-blue),
			0 0 30px var(--neon-blue);
	}
	to {
		text-shadow: 0 0 5px var(--neon-blue), 0 0 10px var(--neon-blue),
			0 0 15px var(--neon-blue);
	}
}

/* Responsive Design */
@media (max-width: 768px) {
	.cyber-glitch {
		font-size: 12vw;
	}

	.floating-panel {
		position: relative;
		width: 90%;
		margin: 20px auto;
		left: auto;
		right: auto;
	}
}

    </style>
  </head>
  <body>
<div id="canvas-container"></div>

<!-- Particle System -->
<canvas id="particle-system"></canvas>

<!-- Main Content -->
<div class="content-wrapper">
	<!-- Cyberpunk-style Header -->
	<header class="cyber-header">
		<div class="glitch-container">
			<h1 class="cyber-glitch" data-text="TYPOGRAPHY">TYPOGRAPHY</h1>
			<div class="scan-line"></div>
		</div>
		<div class="cyber-subtitle">REVOLUTION 2024</div>
	</header>

	<!-- Dynamic Text Sections -->
	<main class="dynamic-content">
		<section class="text-block">
			<div class="kinetic-text">
				<!--<span class="char-shuffle">The future of typography is here</span>-->
			</div>

			<!-- Floating Panels -->
			<div class="floating-panel left">
				<div class="panel-content">
					<h3 class="neon-text">INNOVATION</h3>
					<p class="typing-text">Breaking boundaries of traditional design...</p>
				</div>
			</div>

			<div class="floating-panel right">
				<div class="panel-content">
					<h3 class="neon-text">EVOLUTION</h3>
					<p class="typing-text">Where art meets technology...</p>
				</div>
			</div>
		</section>

		<blockquote class="cyber-quote">
			<p class="quote-text">"Typography is the voice of humanity in the digital age"</p>
			<div class="quote-particles"></div>
		</blockquote>
	</main>
</div>
    <script>
      // Three.js Background Setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
	75,
	window.innerWidth / window.innerHeight,
	0.1,
	1000
);
const renderer = new THREE.WebGLRenderer({ alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.getElementById("canvas-container").appendChild(renderer.domElement);

// Create animated background geometry
const geometry = new THREE.TorusKnotGeometry(10, 3, 100, 16);
const material = new THREE.MeshBasicMaterial({
	color: 0x00f3ff,
	wireframe: true,
	transparent: true,
	opacity: 0.3
});
const torusKnot = new THREE.Mesh(geometry, material);
scene.add(torusKnot);

camera.position.z = 30;

// Particle System
class ParticleSystem {
	constructor() {
		this.canvas = document.getElementById("particle-system");
		this.ctx = this.canvas.getContext("2d");
		this.particles = [];
		this.init();
	}

	init() {
		this.canvas.width = window.innerWidth;
		this.canvas.height = window.innerHeight;
		this.createParticles();
		this.animate();
	}

	createParticles() {
		for (let i = 0; i < 100; i++) {
			this.particles.push({
				x: Math.random() * this.canvas.width,
				y: Math.random() * this.canvas.height,
				size: Math.random() * 2 + 1,
				speedX: Math.random() * 2 - 1,
				speedY: Math.random() * 2 - 1,
				color: `hsl(${Math.random() * 60 + 180}, 100%, 50%)`
			});
		}
	}

	animate() {
		this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

		this.particles.forEach((particle) => {
			particle.x += particle.speedX;
			particle.y += particle.speedY;

			if (particle.x < 0 || particle.x > this.canvas.width) particle.speedX *= -1;
			if (particle.y < 0 || particle.y > this.canvas.height) particle.speedY *= -1;

			this.ctx.beginPath();
			this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
			this.ctx.fillStyle = particle.color;
			this.ctx.fill();
		});

		requestAnimationFrame(() => this.animate());
	}
}

// Character Shuffle Effect
class CharacterShuffle {
	constructor(element) {
		this.element = element;
		this.originalText = element.textContent;
		this.chars = "!<>-_\\/[]{}â€”=+*^?#________";
		this.update();
	}

	update() {
		let iterations = 0;
		const interval = setInterval(() => {
			this.element.textContent = this.originalText
				.split("")
				.map((letter, index) => {
					if (index < iterations) {
						return this.originalText[index];
					}
					return this.chars[Math.floor(Math.random() * this.chars.length)];
				})
				.join("");

			if (iterations >= this.originalText.length) {
				clearInterval(interval);
			}
			iterations += 1 / 3;
		}, 30);
	}
}

// Initialize everything
const particleSystem = new ParticleSystem();
document.querySelectorAll(".char-shuffle").forEach((element) => {
	new CharacterShuffle(element);
});

// Animation loop
function animate() {
	requestAnimationFrame(animate);
	torusKnot.rotation.x += 0.01;
	torusKnot.rotation.y += 0.01;
	renderer.render(scene, camera);
}
animate();

// Window resize handler
window.addEventListener("resize", () => {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
	particleSystem.init();
});

// Scroll-based animations using GSAP
gsap.registerPlugin(ScrollTrigger);

gsap.from(".floating-panel", {
	scrollTrigger: {
		trigger: ".floating-panel",
		start: "top center",
		end: "bottom center",
		scrub: 1
	},
	y: 100,
	opacity: 0,
	duration: 1,
	stagger: 0.2
});

    </script>
  </body>
</html>
